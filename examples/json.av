module JsonParser
    intent =
        "Pure JSON parser. Parses strings into Json sum type."
        "Uses Map for objects. Recursive descent."
    exposes [parse]

type Json
    JsonString(String)
    JsonInt(Int)
    JsonBool(Bool)
    JsonList(List<Json>)
    JsonObject(Map<String, Json>)
    JsonNull

type ParseResult
    Ok(Json, Int)
    Err(String)

fn emptyJsonMap() -> Map<String, Json>
    ? "Create empty Map<String, Json>."
    Map.empty()

fn parse(s: String) -> Result<Json, String>
    ? "Parse JSON string into Json value."
    match parseValue(s, skipWhitespace(s, 0))
        ParseResult.Ok(value, _) -> Result.Ok(value)
        ParseResult.Err(msg) -> Result.Err(msg)

fn skipWhitespace(s: String, pos: Int) -> Int
    ? "Skip whitespace characters."
    match String.charAt(s, pos)
        Option.None -> pos
        Option.Some(c) -> match c
            " " -> skipWhitespace(s, pos + 1)
            "\t" -> skipWhitespace(s, pos + 1)
            "\n" -> skipWhitespace(s, pos + 1)
            "\r" -> skipWhitespace(s, pos + 1)
            _ -> pos

fn parseValue(s: String, pos: Int) -> ParseResult
    ? "Dispatch on first character to parse any JSON value."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unexpected end of input")
        Option.Some(c) -> match c
            "\"" -> parseString(s, pos + 1, "")
            "{{" -> parseObject(s, skipWhitespace(s, pos + 1))
            "[" -> parseArray(s, skipWhitespace(s, pos + 1))
            "t" -> parseLiteral(s, pos, "true", Json.JsonBool(true))
            "f" -> parseLiteral(s, pos, "false", Json.JsonBool(false))
            "n" -> parseLiteral(s, pos, "null", Json.JsonNull)
            "-" -> parseNumber(s, pos + 1, 0, true)
            _ -> tryDigitOrError(s, pos, c)

fn tryDigitOrError(s: String, pos: Int, c: String) -> ParseResult
    ? "Start number if digit, otherwise error."
    match Int.fromString(c)
        Result.Ok(d) -> parseNumber(s, pos + 1, d, false)
        Result.Err(_) -> ParseResult.Err("Unexpected character: " + c)

fn parseLiteral(s: String, pos: Int, expected: String, value: Json) -> ParseResult
    ? "Match exact literal string, return given Json value."
    match expectChars(s, pos, String.chars(expected))
        Option.Some(newPos) -> ParseResult.Ok(value, newPos)
        Option.None -> ParseResult.Err("Expected '" + expected + "'")

fn expectChars(s: String, pos: Int, expected: List<String>) -> Option<Int>
    ? "Check chars at pos match expected sequence."
    match expected
        [] -> Option.Some(pos)
        [h, ..t] -> expectChar(s, pos, h, t)

fn expectChar(s: String, pos: Int, expected: String, rest: List<String>) -> Option<Int>
    ? "Match one expected char and continue."
    match String.charAt(s, pos)
        Option.None -> Option.None
        Option.Some(c) -> expectIfEqual(s, pos, c, expected, rest)

fn expectIfEqual(s: String, pos: Int, actual: String, expected: String, rest: List<String>) -> Option<Int>
    ? "Continue matching if chars equal."
    match actual == expected
        true -> expectChars(s, pos + 1, rest)
        false -> Option.None

fn parseString(s: String, pos: Int, accum: String) -> ParseResult
    ? "Accumulate string chars until closing quote."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated string")
        Option.Some(c) -> match c
            "\"" -> ParseResult.Ok(Json.JsonString(accum), pos + 1)
            "\\" -> parseEscape(s, pos + 1, accum)
            _ -> parseString(s, pos + 1, accum + c)

fn parseEscape(s: String, pos: Int, accum: String) -> ParseResult
    ? "Handle escape sequence after backslash."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated escape")
        Option.Some(c) -> match c
            "\"" -> parseString(s, pos + 1, accum + "\"")
            "\\" -> parseString(s, pos + 1, accum + "\\")
            "/" -> parseString(s, pos + 1, accum + "/")
            "n" -> parseString(s, pos + 1, accum + "\n")
            "t" -> parseString(s, pos + 1, accum + "\t")
            "r" -> parseString(s, pos + 1, accum + "\r")
            _ -> ParseResult.Err("Unknown escape: \\" + c)

fn parseNumber(s: String, pos: Int, accum: Int, negative: Bool) -> ParseResult
    ? "Accumulate digits into integer."
    match String.charAt(s, pos)
        Option.None -> finishNumber(accum, negative, pos)
        Option.Some(c) -> tryAccumDigit(s, pos, accum, negative, c)

fn tryAccumDigit(s: String, pos: Int, accum: Int, negative: Bool, c: String) -> ParseResult
    ? "If digit accumulate, otherwise finish number."
    match Int.fromString(c)
        Result.Ok(d) -> parseNumber(s, pos + 1, accum * 10 + d, negative)
        Result.Err(_) -> finishNumber(accum, negative, pos)

fn finishNumber(accum: Int, negative: Bool, pos: Int) -> ParseResult
    ? "Apply sign and return finished number."
    match negative
        true -> ParseResult.Ok(Json.JsonInt(accum * -1), pos)
        false -> ParseResult.Ok(Json.JsonInt(accum), pos)

fn parseArray(s: String, pos: Int) -> ParseResult
    ? "Parse array after opening bracket."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated array")
        Option.Some(c) -> match c
            "]" -> ParseResult.Ok(Json.JsonList([]), pos + 1)
            _ -> parseArrayElements(s, pos, [])

fn parseArrayElements(s: String, pos: Int, accum: List<Json>) -> ParseResult
    ? "Parse comma-separated values in array."
    match parseValue(s, pos)
        ParseResult.Err(msg) -> ParseResult.Err(msg)
        ParseResult.Ok(value, newPos) -> parseArrayNext(s, skipWhitespace(s, newPos), List.push(accum, value))

fn parseArrayNext(s: String, pos: Int, accum: List<Json>) -> ParseResult
    ? "After array value expect comma or bracket."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated array")
        Option.Some(c) -> match c
            "]" -> ParseResult.Ok(Json.JsonList(accum), pos + 1)
            "," -> parseArrayElements(s, skipWhitespace(s, pos + 1), accum)
            _ -> ParseResult.Err("Expected ',' or ']'")

fn parseObject(s: String, pos: Int) -> ParseResult
    ? "Parse object after opening brace."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object")
        Option.Some(c) -> match c
            "}}" -> ParseResult.Ok(Json.JsonObject(emptyJsonMap()), pos + 1)
            _ -> parseObjectFields(s, pos, emptyJsonMap())

fn parseObjectFields(s: String, pos: Int, accum: Map<String, Json>) -> ParseResult
    ? "Parse key:value pairs in object."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object")
        Option.Some(c) -> match c
            "\"" -> parseObjectKey(s, pos + 1, accum)
            _ -> ParseResult.Err("Expected string key")

fn parseObjectKey(s: String, pos: Int, accum: Map<String, Json>) -> ParseResult
    ? "Parse key then expect colon."
    match parseString(s, pos, "")
        ParseResult.Err(msg) -> ParseResult.Err(msg)
        ParseResult.Ok(keyJson, newPos) -> parseObjectColon(s, skipWhitespace(s, newPos), accum, extractString(keyJson))

fn extractString(j: Json) -> String
    ? "Extract string from JsonString."
    match j
        Json.JsonString(s) -> s
        _ -> ""

fn parseObjectColon(s: String, pos: Int, accum: Map<String, Json>, key: String) -> ParseResult
    ? "Expect colon then parse value."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object")
        Option.Some(c) -> match c
            ":" -> parseObjectValue(s, skipWhitespace(s, pos + 1), accum, key)
            _ -> ParseResult.Err("Expected ':'")

fn parseObjectValue(s: String, pos: Int, accum: Map<String, Json>, key: String) -> ParseResult
    ? "Parse value and add to object map."
    match parseValue(s, pos)
        ParseResult.Err(msg) -> ParseResult.Err(msg)
        ParseResult.Ok(value, newPos) -> parseObjectNext(s, skipWhitespace(s, newPos), Map.set(accum, key, value))

fn parseObjectNext(s: String, pos: Int, accum: Map<String, Json>) -> ParseResult
    ? "After object value expect comma or brace."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object")
        Option.Some(c) -> match c
            "}}" -> ParseResult.Ok(Json.JsonObject(accum), pos + 1)
            "," -> parseObjectFields(s, skipWhitespace(s, pos + 1), accum)
            _ -> ParseResult.Err("Expected ',' or '}'")

fn getField(j: Json, key: String) -> Option<Json>
    ? "Extract a field from a JsonObject by key."
    match j
        Json.JsonObject(m) -> Map.get(m, key)
        _ -> Option.None

fn jsonStr(j: Json) -> String
    ? "Extract raw string from JsonString."
    match j
        Json.JsonString(s) -> s
        _ -> ""

fn jsonInt(j: Json) -> Int
    ? "Extract raw int from JsonInt."
    match j
        Json.JsonInt(n) -> n
        _ -> 0

fn jsonList(j: Json) -> List<Json>
    ? "Extract list from JsonList."
    match j
        Json.JsonList(items) -> items
        _ -> []

fn showTag(tag: Json) -> String
    ? "Show a tag string with hash prefix."
    = "#" + jsonStr(tag)

fn main() -> Unit
    ! [Console]
    json = "{{ \"company\": \"Aver Labs\", \"founded\": 2024, \"active\": true, \"address\": {{ \"city\": \"Warszawa\", \"country\": \"Poland\", \"zip\": \"00-001\" }}, \"team\": [{{ \"name\": \"Jan\", \"role\": \"lead\" }}, {{ \"name\": \"Anna\", \"role\": \"dev\" }}, {{ \"name\": \"Piotr\", \"role\": \"ops\" }}], \"tags\": [\"lang-design\", \"rust\", \"ai-first\"], \"funding\": null }}"

    Console.print("Parsing complex nested JSON...")
    match parse(json)
        Result.Err(msg) -> Console.print("Parse error: " + msg)
        Result.Ok(root) -> printReport(root)

fn printReport(root: Json) -> Unit
    ! [Console]
    company = getField(root, "company")
    founded = getField(root, "founded")
    address = getField(root, "address")
    team = getField(root, "team")
    tags = getField(root, "tags")
    funding = getField(root, "funding")

    match company
        Option.Some(c) -> Console.print("Company: " + jsonStr(c))
        Option.None -> Console.print("Company: ?")

    match founded
        Option.Some(f) -> Console.print("Founded: " + String.fromInt(jsonInt(f)))
        Option.None -> Console.print("Founded: ?")

    match address
        Option.Some(addr) -> printAddress(addr)
        Option.None -> Console.print("Address: ?")

    match team
        Option.Some(t) -> printTeam(jsonList(t))
        Option.None -> Console.print("Team: ?")

    match tags
        Option.Some(t) -> Console.print("Tags: " + String.join(List.map(jsonList(t), showTag), ", "))
        Option.None -> Console.print("Tags: ?")

    match funding
        Option.Some(f) -> match f
            Json.JsonNull -> Console.print("Funding: none yet")
            _ -> Console.print("Funding: present")
        Option.None -> Console.print("Funding: ?")

fn printAddress(addr: Json) -> Unit
    ! [Console]
    city = getField(addr, "city")
    country = getField(addr, "country")
    match city
        Option.Some(c) -> match country
            Option.Some(co) -> Console.print("Address: " + jsonStr(c) + ", " + jsonStr(co))
            Option.None -> Console.print("Address: " + jsonStr(c))
        Option.None -> Console.print("Address: ?")

fn printTeam(members: List<Json>) -> Unit
    ! [Console]
    Console.print("Team (" + String.fromInt(List.len(members)) + " members):")
    _ = List.map(members, printMember)

fn printMember(member: Json) -> Unit
    ! [Console]
    name = getField(member, "name")
    role = getField(member, "role")
    match name
        Option.Some(n) -> match role
            Option.Some(r) -> Console.print("  " + jsonStr(n) + " (" + jsonStr(r) + ")")
            Option.None -> Console.print("  " + jsonStr(n))
        Option.None -> Console.print("  (unknown)")

verify parse
    parse("null") => Result.Ok(Json.JsonNull)
    parse("true") => Result.Ok(Json.JsonBool(true))
    parse("false") => Result.Ok(Json.JsonBool(false))
    parse("42") => Result.Ok(Json.JsonInt(42))
    parse("-7") => Result.Ok(Json.JsonInt(-7))
    parse("0") => Result.Ok(Json.JsonInt(0))
    parse("\"hello\"") => Result.Ok(Json.JsonString("hello"))
    parse("\"he\\nllo\"") => Result.Ok(Json.JsonString("he\nllo"))
    parse("\"\"") => Result.Ok(Json.JsonString(""))
    parse("[]") => Result.Ok(Json.JsonList([]))
    parse("[1,2,3]") => Result.Ok(Json.JsonList([Json.JsonInt(1), Json.JsonInt(2), Json.JsonInt(3)]))
    parse("{{}}") => Result.Ok(Json.JsonObject(emptyJsonMap()))
    parse("{{\"a\":1}}") => Result.Ok(Json.JsonObject(Map.fromList([("a", Json.JsonInt(1))])))
    parse("  {{ \"x\" : [1, 2] , \"y\" : null }}  ") => Result.Ok(Json.JsonObject(Map.fromList([("x", Json.JsonList([Json.JsonInt(1), Json.JsonInt(2)])), ("y", Json.JsonNull)])))
