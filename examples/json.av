module JsonParser
    intent =
        "RFC 8259 JSON parser. Recursive descent, pure, no effects."
        "Supports: integers, floats, strings (with \\uXXXX), bools, null, arrays, objects."
        "Validates: trailing content, leading zeros, control chars, invalid escapes."
    exposes [parse]

type Json
    JsonString(String)
    JsonInt(Int)
    JsonFloat(Float)
    JsonBool(Bool)
    JsonList(List<Json>)
    JsonObject(Map<String, Json>)
    JsonNull

type ParseResult
    Ok(Json, Int)
    Err(String, Int)

// â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn parse(s: String) -> Result<Json, String>
    ? "Parse a JSON string into a Json value."
    match parseValue(s, skipWs(s, 0))
        ParseResult.Err(msg, p) -> Result.Err(msg + " at position " + String.fromInt(p))
        ParseResult.Ok(val, p) -> checkEof(s, val, skipWs(s, p))

fn checkEof(s: String, val: Json, pos: Int) -> Result<Json, String>
    match String.charAt(s, pos)
        Option.None -> Result.Ok(val)
        Option.Some(c) -> Result.Err("Trailing content: " + c + " at position " + String.fromInt(pos))

// â”€â”€ Char helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn isDigit(c: String) -> Bool
    code = Char.toCode(c)
    match code >= 48
        true -> code <= 57
        false -> false

fn digitVal(c: String) -> Int
    = Char.toCode(c) - 48

fn hexVal(c: String) -> Option<Int>
    ? "Hex digit value: 0-9, a-f, A-F. None for non-hex."
    match isDigit(c)
        true -> Option.Some(digitVal(c))
        false -> hexAlpha(Char.toCode(c))

fn hexAlpha(code: Int) -> Option<Int>
    match code >= 97
        true -> match code <= 102
            true -> Option.Some(code - 87)
            false -> Option.None
        false -> match code >= 65
            true -> match code <= 70
                true -> Option.Some(code - 55)
                false -> Option.None
            false -> Option.None

// â”€â”€ Whitespace â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn skipWs(s: String, pos: Int) -> Int
    match String.charAt(s, pos)
        Option.None -> pos
        Option.Some(c) -> match c
            " " -> skipWs(s, pos + 1)
            "\t" -> skipWs(s, pos + 1)
            "\n" -> skipWs(s, pos + 1)
            "\r" -> skipWs(s, pos + 1)
            _ -> pos

// â”€â”€ Value dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn parseValue(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unexpected end of input", pos)
        Option.Some(c) -> dispatchChar(s, pos, c)

fn dispatchChar(s: String, pos: Int, c: String) -> ParseResult
    match c
        "\"" -> parseString(s, pos + 1)
        "{{" -> parseObject(s, skipWs(s, pos + 1))
        "[" -> parseArray(s, skipWs(s, pos + 1))
        "t" -> parseLiteral(s, pos, "true", Json.JsonBool(true))
        "f" -> parseLiteral(s, pos, "false", Json.JsonBool(false))
        "n" -> parseLiteral(s, pos, "null", Json.JsonNull)
        "-" -> parseNumber(s, pos)
        _ -> dispatchNumberOrErr(s, pos, c)

fn dispatchNumberOrErr(s: String, pos: Int, c: String) -> ParseResult
    match isDigit(c)
        true -> parseNumber(s, pos)
        false -> ParseResult.Err("Unexpected character: " + c, pos)

// â”€â”€ Literals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn parseLiteral(s: String, pos: Int, expected: String, value: Json) -> ParseResult
    ? "Match exact keyword using slice comparison."
    len = String.len(expected)
    match String.slice(s, pos, pos + len) == expected
        true -> ParseResult.Ok(value, pos + len)
        false -> ParseResult.Err("Expected '" + expected + "'", pos)

// â”€â”€ Strings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn parseString(s: String, pos: Int) -> ParseResult
    ? "Parse string using segment chunks to avoid repeated concatenation."
    = parseStringChunk(s, pos, pos, [])

fn parseStringChunk(s: String, pos: Int, segmentStart: Int, chunks: List<String>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated string", pos)
        Option.Some(c) -> match c
            "\"" -> finishString(s, pos + 1, segmentStart, chunks)
            "\\" -> parseEscape(s, pos + 1, pos, segmentStart, chunks)
            _ -> validateChar(s, pos, segmentStart, chunks, c)

fn finishString(s: String, nextPos: Int, segmentStart: Int, chunks: List<String>) -> ParseResult
    segment = String.slice(s, segmentStart, nextPos - 1)
    all = String.join(List.push(chunks, segment), "")
    ParseResult.Ok(Json.JsonString(all), nextPos)

fn validateChar(s: String, pos: Int, segmentStart: Int, chunks: List<String>, c: String) -> ParseResult
    match Char.toCode(c) < 32
        true -> ParseResult.Err("Unescaped control character", pos)
        false -> parseStringChunk(s, pos + 1, segmentStart, chunks)

fn parseEscape(s: String, pos: Int, slashPos: Int, segmentStart: Int, chunks: List<String>) -> ParseResult
    segment = String.slice(s, segmentStart, slashPos)
    base = List.push(chunks, segment)
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated escape", pos)
        Option.Some(c) -> match c
            "\"" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\""))
            "\\" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\\"))
            "/" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "/"))
            "n" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\n"))
            "t" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\t"))
            "r" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\r"))
            "b" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\b"))
            "f" -> parseStringChunk(s, pos + 1, pos + 1, List.push(base, "\f"))
            "u" -> parseUnicode(s, pos + 1, pos + 1, base)
            _ -> ParseResult.Err("Unknown escape: \\" + c, pos)

fn parseUnicode(s: String, pos: Int, escapePos: Int, chunks: List<String>) -> ParseResult
    ? "Parse \\uXXXX, including surrogate pairs."
    match readHex4(s, pos, 0, 0)
        Option.None -> ParseResult.Err("Invalid \\u escape", escapePos)
        Option.Some(cp) -> parseUnicodeCodePoint(s, pos + 4, escapePos, chunks, cp)

fn parseUnicodeCodePoint(s: String, pos: Int, escapePos: Int, chunks: List<String>, cp: Int) -> ParseResult
    match isHighSurrogate(cp)
        true -> parseUnicodePair(s, pos, escapePos, chunks, cp)
        false -> match isLowSurrogate(cp)
            true -> ParseResult.Err("Invalid Unicode surrogate pair", escapePos)
            false -> applyCodePoint(s, pos, escapePos, chunks, cp)

fn isHighSurrogate(cp: Int) -> Bool
    match cp >= 55296
        true -> cp <= 56319
        false -> false

fn isLowSurrogate(cp: Int) -> Bool
    match cp >= 56320
        true -> cp <= 57343
        false -> false

fn parseUnicodePair(s: String, pos: Int, escapePos: Int, chunks: List<String>, hi: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Invalid Unicode surrogate pair", escapePos)
        Option.Some(c) -> match c
            "\\" -> parseUnicodePairU(s, pos + 1, escapePos, chunks, hi)
            _ -> ParseResult.Err("Invalid Unicode surrogate pair", escapePos)

fn parseUnicodePairU(s: String, pos: Int, escapePos: Int, chunks: List<String>, hi: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Invalid Unicode surrogate pair", escapePos)
        Option.Some(c) -> match c
            "u" -> parseUnicodePairLow(s, pos + 1, escapePos, chunks, hi)
            _ -> ParseResult.Err("Invalid Unicode surrogate pair", escapePos)

fn parseUnicodePairLow(s: String, pos: Int, escapePos: Int, chunks: List<String>, hi: Int) -> ParseResult
    match readHex4(s, pos, 0, 0)
        Option.None -> ParseResult.Err("Invalid \\u escape", pos - 1)
        Option.Some(lo) -> match isLowSurrogate(lo)
            true -> applyCodePoint(s, pos + 4, escapePos, chunks, combineSurrogates(hi, lo))
            false -> ParseResult.Err("Invalid Unicode surrogate pair", escapePos)

fn combineSurrogates(hi: Int, lo: Int) -> Int
    = 65536 + (hi - 55296) * 1024 + (lo - 56320)

fn readHex4(s: String, pos: Int, acc: Int, count: Int) -> Option<Int>
    match count == 4
        true -> Option.Some(acc)
        false -> match String.charAt(s, pos)
            Option.None -> Option.None
            Option.Some(c) -> match hexVal(c)
                Option.None -> Option.None
                Option.Some(v) -> readHex4(s, pos + 1, acc * 16 + v, count + 1)

fn applyCodePoint(s: String, pos: Int, escapePos: Int, chunks: List<String>, cp: Int) -> ParseResult
    match Char.fromCode(cp)
        Option.None -> ParseResult.Err("Invalid Unicode code point", escapePos)
        Option.Some(ch) -> parseStringChunk(s, pos, pos, List.push(chunks, ch))

// â”€â”€ Numbers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn parseNumber(s: String, start: Int) -> ParseResult
    ? "Parse JSON number using source slices (avoids Int overflow during scan)."
    match String.charAt(s, start)
        Option.None -> ParseResult.Err("Unexpected end of input", start)
        Option.Some(c) -> match c
            "-" -> parseNumberSign(s, start + 1, start)
            "0" -> scanIntTail(s, start + 1, start, true)
            _ -> startNumberDigits(s, start, c)

fn startNumberDigits(s: String, start: Int, c: String) -> ParseResult
    match isDigit(c)
        true -> scanIntTail(s, start + 1, start, false)
        false -> ParseResult.Err("Unexpected character: " + c, start)

fn parseNumberSign(s: String, pos: Int, start: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit after '-'", pos)
        Option.Some(c) -> match c
            "0" -> scanIntTail(s, pos + 1, start, true)
            _ -> startSignDigit(s, pos, start, c)

fn startSignDigit(s: String, pos: Int, start: Int, c: String) -> ParseResult
    match isDigit(c)
        true -> scanIntTail(s, pos + 1, start, false)
        false -> ParseResult.Err("Expected digit after '-'", pos)

fn scanIntTail(s: String, pos: Int, start: Int, leadingZero: Bool) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> finishNumber(s, start, pos, false)
        Option.Some(c) -> match isDigit(c)
            true -> match leadingZero
                true -> ParseResult.Err("Leading zeros not allowed", pos)
                false -> scanIntTail(s, pos + 1, start, false)
            false -> afterIntChar(s, pos, start, c)

fn afterIntChar(s: String, pos: Int, start: Int, c: String) -> ParseResult
    match c
        "." -> scanFracFirst(s, pos + 1, start)
        "e" -> scanExpStart(s, pos + 1, start)
        "E" -> scanExpStart(s, pos + 1, start)
        _ -> finishNumber(s, start, pos, false)

fn scanFracFirst(s: String, pos: Int, start: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit after '.'", pos)
        Option.Some(c) -> match isDigit(c)
            true -> scanFracTail(s, pos + 1, start)
            false -> ParseResult.Err("Expected digit after '.'", pos)

fn scanFracTail(s: String, pos: Int, start: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> finishNumber(s, start, pos, true)
        Option.Some(c) -> match isDigit(c)
            true -> scanFracTail(s, pos + 1, start)
            false -> afterFracChar(s, pos, start, c)

fn afterFracChar(s: String, pos: Int, start: Int, c: String) -> ParseResult
    match c
        "e" -> scanExpStart(s, pos + 1, start)
        "E" -> scanExpStart(s, pos + 1, start)
        _ -> finishNumber(s, start, pos, true)

fn scanExpStart(s: String, pos: Int, start: Int) -> ParseResult
    ? "Parse exponent: optional sign then at least one digit."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit in exponent", pos)
        Option.Some(c) -> match c
            "+" -> scanExpDigit1(s, pos + 1, start)
            "-" -> scanExpDigit1(s, pos + 1, start)
            _ -> startExpDigit(s, pos, start, c)

fn scanExpDigit1(s: String, pos: Int, start: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit in exponent", pos)
        Option.Some(c) -> startExpDigit(s, pos, start, c)

fn startExpDigit(s: String, pos: Int, start: Int, c: String) -> ParseResult
    match isDigit(c)
        true -> scanExpTail(s, pos + 1, start)
        false -> ParseResult.Err("Expected digit in exponent", pos)

fn scanExpTail(s: String, pos: Int, start: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> finishNumber(s, start, pos, true)
        Option.Some(c) -> match isDigit(c)
            true -> scanExpTail(s, pos + 1, start)
            false -> finishNumber(s, start, pos, true)

fn finishNumber(s: String, start: Int, endPos: Int, asFloat: Bool) -> ParseResult
    num = String.slice(s, start, endPos)
    match asFloat
        true -> finishFloat(num, endPos)
        false -> finishInt(num, endPos)

fn finishInt(num: String, pos: Int) -> ParseResult
    match Int.fromString(num)
        Result.Ok(n) -> ParseResult.Ok(Json.JsonInt(n), pos)
        Result.Err(_) -> ParseResult.Err("Invalid number: " + num, pos)

fn finishFloat(num: String, pos: Int) -> ParseResult
    match Float.fromString(num)
        Result.Ok(f) -> ParseResult.Ok(Json.JsonFloat(f), pos)
        Result.Err(_) -> ParseResult.Err("Invalid number: " + num, pos)

// â”€â”€ Arrays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn parseArray(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated array", pos)
        Option.Some(c) -> match c
            "]" -> ParseResult.Ok(Json.JsonList([]), pos + 1)
            _ -> parseArrayElems(s, pos, [])

fn parseArrayElems(s: String, pos: Int, acc: List<Json>) -> ParseResult
    match parseValue(s, pos)
        ParseResult.Err(msg, p) -> ParseResult.Err(msg, p)
        ParseResult.Ok(val, p) -> parseArrayNext(s, skipWs(s, p), List.push(acc, val))

fn parseArrayNext(s: String, pos: Int, acc: List<Json>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated array", pos)
        Option.Some(c) -> match c
            "]" -> ParseResult.Ok(Json.JsonList(acc), pos + 1)
            "," -> parseArrayElems(s, skipWs(s, pos + 1), acc)
            _ -> ParseResult.Err("Expected ',' or ']'", pos)

// â”€â”€ Objects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn emptyJsonMap() -> Map<String, Json>
    = Map.empty()

fn parseObject(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            "}}" -> ParseResult.Ok(Json.JsonObject(emptyJsonMap()), pos + 1)
            _ -> parseObjFields(s, pos, emptyJsonMap())

fn parseObjFields(s: String, pos: Int, acc: Map<String, Json>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            "\"" -> parseObjKey(s, pos + 1, acc)
            _ -> ParseResult.Err("Expected string key", pos)

fn parseObjKey(s: String, pos: Int, acc: Map<String, Json>) -> ParseResult
    match parseString(s, pos)
        ParseResult.Err(msg, p) -> ParseResult.Err(msg, p)
        ParseResult.Ok(keyJson, p) -> parseObjKeyValue(s, p, acc, keyJson)

fn parseObjKeyValue(s: String, pos: Int, acc: Map<String, Json>, keyJson: Json) -> ParseResult
    match keyJson
        Json.JsonString(key) -> parseObjColon(s, skipWs(s, pos), acc, key)
        _ -> ParseResult.Err("Expected string key", pos)

fn parseObjColon(s: String, pos: Int, acc: Map<String, Json>, key: String) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            ":" -> parseObjVal(s, skipWs(s, pos + 1), acc, key)
            _ -> ParseResult.Err("Expected ':'", pos)

fn parseObjVal(s: String, pos: Int, acc: Map<String, Json>, key: String) -> ParseResult
    match parseValue(s, pos)
        ParseResult.Err(msg, p) -> ParseResult.Err(msg, p)
        ParseResult.Ok(val, p) -> parseObjNext(s, skipWs(s, p), Map.set(acc, key, val))

fn parseObjNext(s: String, pos: Int, acc: Map<String, Json>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            "}}" -> ParseResult.Ok(Json.JsonObject(acc), pos + 1)
            "," -> parseObjFields(s, skipWs(s, pos + 1), acc)
            _ -> ParseResult.Err("Expected ',' or '}'", pos)

// â”€â”€ Extractors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn getField(j: Json, key: String) -> Option<Json>
    match j
        Json.JsonObject(m) -> Map.get(m, key)
        _ -> Option.None

fn jsonStr(j: Json) -> String
    match j
        Json.JsonString(s) -> s
        _ -> ""

fn jsonInt(j: Json) -> Int
    match j
        Json.JsonInt(n) -> n
        _ -> 0

fn jsonFloat(j: Json) -> Float
    match j
        Json.JsonFloat(f) -> f
        _ -> 0.0

fn jsonList(j: Json) -> List<Json>
    match j
        Json.JsonList(items) -> items
        _ -> []

// â”€â”€ Demo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn main() -> Unit
    ! [Console]
    json = "{{ \"name\": \"Aver Labs\", \"score\": 9.75, \"motto\": \"caf\\u00e9 au code\", \"team\": [\"Jan\", \"Anna\"] }}"
    Console.print("Parsing JSON...")
    match parse(json)
        Result.Err(msg) -> Console.print("Error: " + msg)
        Result.Ok(root) -> printResult(root)

fn printResult(root: Json) -> Unit
    ! [Console]
    match getField(root, "name")
        Option.Some(v) -> Console.print("Name: " + jsonStr(v))
        Option.None -> Console.print("Name: ?")
    match getField(root, "score")
        Option.Some(v) -> Console.print("Score: " + String.fromFloat(jsonFloat(v)))
        Option.None -> Console.print("Score: ?")
    match getField(root, "motto")
        Option.Some(v) -> Console.print("Motto: " + jsonStr(v))
        Option.None -> Console.print("Motto: ?")
    match getField(root, "team")
        Option.Some(t) -> Console.print("Team: " + String.join(List.map(jsonList(t), jsonStr), ", "))
        Option.None -> Console.print("Team: ?")

// â”€â”€ Verify: primitives â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

verify parse
    parse("null") => Result.Ok(Json.JsonNull)
    parse("true") => Result.Ok(Json.JsonBool(true))
    parse("false") => Result.Ok(Json.JsonBool(false))
    parse("42") => Result.Ok(Json.JsonInt(42))
    parse("-7") => Result.Ok(Json.JsonInt(-7))
    parse("0") => Result.Ok(Json.JsonInt(0))
    parse("-0") => Result.Ok(Json.JsonInt(0))

// â”€â”€ Verify: floats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

verify parse
    parse("1.5") => Result.Ok(Json.JsonFloat(1.5))
    parse("0.5") => Result.Ok(Json.JsonFloat(0.5))
    parse("-3.14") => Result.Ok(Json.JsonFloat(-3.14))
    parse("1e2") => Result.Ok(Json.JsonFloat(100.0))
    parse("1E2") => Result.Ok(Json.JsonFloat(100.0))
    parse("1e+2") => Result.Ok(Json.JsonFloat(100.0))
    parse("1e-1") => Result.Ok(Json.JsonFloat(0.1))
    parse("1.5e1") => Result.Ok(Json.JsonFloat(15.0))
    parse("0e5") => Result.Ok(Json.JsonFloat(0.0))
    parse("-2.5e3") => Result.Ok(Json.JsonFloat(-2500.0))

// â”€â”€ Verify: strings and unicode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

verify parse
    parse("\"hello\"") => Result.Ok(Json.JsonString("hello"))
    parse("\"\"") => Result.Ok(Json.JsonString(""))
    parse("\"he\\nllo\"") => Result.Ok(Json.JsonString("he\nllo"))
    parse("\"\\u0041\"") => Result.Ok(Json.JsonString("A"))
    parse("\"caf\\u00e9\"") => Result.Ok(Json.JsonString("cafÃ©"))
    parse("\"\\uD83D\\uDE00\"") => Result.Ok(Json.JsonString("ðŸ˜€"))

// â”€â”€ Verify: collections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

verify parse
    parse("[]") => Result.Ok(Json.JsonList([]))
    parse("[1,2,3]") => Result.Ok(Json.JsonList([Json.JsonInt(1), Json.JsonInt(2), Json.JsonInt(3)]))
    parse("{{}}") => Result.Ok(Json.JsonObject(emptyJsonMap()))
    parse("{{\"a\":1}}") => Result.Ok(Json.JsonObject(Map.fromList([("a", Json.JsonInt(1))])))
    parse("  {{ \"x\" : [1, 2] , \"y\" : null }}  ") => Result.Ok(Json.JsonObject(Map.fromList([("x", Json.JsonList([Json.JsonInt(1), Json.JsonInt(2)])), ("y", Json.JsonNull)])))

// â”€â”€ Verify: errors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

verify parse
    parse("true false") => Result.Err("Trailing content: f at position 5")
    parse("42oops") => Result.Err("Trailing content: o at position 2")
    parse("-") => Result.Err("Expected digit after '-' at position 1")
    parse("01") => Result.Err("Leading zeros not allowed at position 1")
    parse("-01") => Result.Err("Leading zeros not allowed at position 2")
    parse("1.") => Result.Err("Expected digit after '.' at position 2")
    parse("1e") => Result.Err("Expected digit in exponent at position 2")
    parse("1e+") => Result.Err("Expected digit in exponent at position 3")
    parse("\"\\uXXXX\"") => Result.Err("Invalid \\u escape at position 3")
    parse("\"\\uD800\"") => Result.Err("Invalid Unicode surrogate pair at position 3")
    parse("\"\t\"") => Result.Err("Unescaped control character at position 1")
