module Redis
    intent =
        "Minimal Redis client over raw TCP using the RESP protocol."
        "Demonstrates persistent Tcp connections: connect once, issue multiple"
        "commands on the same socket, close explicitly."
    exposes [connect, disconnect, ping, set, get, del]
    depends []

decision RespOverTcp
    date = "2026-02-25"
    reason =
        "Redis speaks RESP (REdis Serialization Protocol), a text protocol over"
        "TCP. RESP commands are plain lines terminated by CRLF, which maps"
        "directly onto Tcp.writeLine / Tcp.readLine. No binary framing or"
        "external library is needed."
    chosen = RawTcpWithRespText
    rejected = [HttpAdapter, NativeRedisDriver]
    impacts = [Redis]
    author = "szymon"

decision ConnectionIdPattern
    date = "2026-02-26"
    reason =
        "Value must be Clone + PartialEq, so TcpStream cannot live inside a"
        "Value directly. Tcp.connect returns an opaque Tcp.Connection record"
        "(id, host, port) that is threaded through subsequent calls."
        "The actual socket lives in a thread-local HashMap keyed by the id."
    chosen = OpaqueConnectionRecord
    rejected = [StreamInValue, GlobalConnectionPool, BareStringHandle]
    impacts = [Redis, Tcp]
    author = "szymon"

// Config

record RedisConfig
    host: String
    port: Int

// RESP helpers (pure, verifiable)

fn respBulkLen(s: String) -> String
    ? "Returns the byte-length of s as a string, used to build RESP bulk-string headers."
    = Int.toString(String.byteLength(s))

verify respBulkLen
    respBulkLen("PING") => "4"
    respBulkLen("OK")   => "2"
    respBulkLen("")     => "0"
    respBulkLen("SET")  => "3"

// RESP framing
//
// A RESP command with N args is sent as:
//   *N\r\n
//   $String.byteLength(arg1)\r\n  arg1\r\n
//   $String.byteLength(arg2)\r\n  arg2\r\n
//   ...
//
// sendCommand writes the *N header, then delegates to sendArgs.
// sendArgs / sendArgAndRest recurse over the arg list.
// Both return Result<String, String> where Ok carries conn, avoiding Ok(Unit).

fn sendArgAndRest(conn: Tcp.Connection, h: String, t: List<String>) -> Result<Tcp.Connection, String>
    ? "Sends one RESP bulk-string arg ('$len' + data), then recurses for the rest."
    ! [Tcp]
    _ = Tcp.writeLine(conn, "${respBulkLen(h)}")?
    _ = Tcp.writeLine(conn, h)?
    sendArgs(conn, t)

fn sendArgs(conn: Tcp.Connection, args: List<String>) -> Result<Tcp.Connection, String>
    ? "Recursively sends each element of args as a RESP bulk string."
    ! [Tcp]
    match args
        []       -> Result.Ok(conn)
        [h, ..t] -> sendArgAndRest(conn, h, t)

fn sendCommand(conn: Tcp.Connection, args: List<String>) -> Result<Tcp.Connection, String>
    ? "Sends a full RESP command: writes the '*N' array header then each arg via sendArgs."
    ! [Tcp]
    _ = Tcp.writeLine(conn, "*{Int.toString(List.len(args))}")?
    sendArgs(conn, args)

// Public API

fn connect(cfg: RedisConfig) -> Result<Tcp.Connection, String>
    ? "Opens a TCP connection to Redis and returns the connection record."
    ! [Tcp]
    Tcp.connect(cfg.host, cfg.port)

fn disconnect(conn: Tcp.Connection) -> Result<Unit, String>
    ? "Closes the TCP connection identified by conn."
    ! [Tcp]
    Tcp.close(conn)

fn ping(conn: Tcp.Connection) -> Result<String, String>
    ? "Sends PING and returns the server reply (expected: +PONG)."
    ! [Tcp]
    _ = sendCommand(conn, ["PING"])?
    Tcp.readLine(conn)

fn set(conn: Tcp.Connection, key: String, value: String) -> Result<String, String>
    ? "Sends SET key value and returns the server reply (expected: +OK)."
    ! [Tcp]
    _ = sendCommand(conn, ["SET", key, value])?
    Tcp.readLine(conn)

fn get(conn: Tcp.Connection, key: String) -> Result<String, String>
    ? "Sends GET key. Returns Ok(value) or Err('key not found') when Redis replies $-1 (nil)."
    ! [Tcp]
    _ = sendCommand(conn, ["GET", key])?
    header = Tcp.readLine(conn)?
    match header == "$-1"
        true  -> Result.Err("key not found")
        false -> Tcp.readLine(conn)

fn del(conn: Tcp.Connection, key: String) -> Result<String, String>
    ? "Sends DEL key and returns the raw RESP reply (expected: :N deleted count)."
    ! [Tcp]
    _ = sendCommand(conn, ["DEL", key])?
    Tcp.readLine(conn)

// Demo entry point

fn run() -> Result<Unit, String>
    ? "Full Redis demo: connect, PING, SET, GET, DEL, disconnect."
    ! [Tcp, Console]
    cfg  = RedisConfig(host = "127.0.0.1", port = 6379)
    conn = connect(cfg)?

    pong = ping(conn)?
    Console.print("PING -> {pong}")

    setR = set(conn, "aver:key", "hello from Aver")?
    Console.print("SET  -> {setR}")

    getR = get(conn, "aver:key")?
    Console.print("GET  -> {getR}")

    delR = del(conn, "aver:key")?
    Console.print("DEL  -> {delR}")

    closed = disconnect(conn)
    Console.print("connection closed.")
    closed

fn main() -> Unit
    ! [Tcp, Console]
    match run()
        Result.Ok(_)  -> Console.print("done.")
        Result.Err(e) -> Console.print("error: {e}")
