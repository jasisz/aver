use aver::ast::{DecisionBlock, FnDef, TypeDef};
use aver::checker::expr_to_str;

use crate::context_data::FileContext;

pub(super) fn format_context_md(contexts: &[FileContext], entry_file: &str) -> String {
    let mut out = String::new();
    out.push_str(&format!("# Aver Context — {}\n\n", entry_file));
    out.push_str("_Generated by `aver context`_\n\n");

    let all_decisions: Vec<&DecisionBlock> =
        contexts.iter().flat_map(|c| c.decisions.iter()).collect();

    for ctx in contexts {
        let has_content =
            !ctx.fn_defs.is_empty() || !ctx.type_defs.is_empty() || !ctx.effect_sets.is_empty();

        if !has_content && ctx.module_name.is_none() {
            continue;
        }

        out.push_str("---\n\n");

        if let Some(name) = &ctx.module_name {
            out.push_str(&format!("## Module: {}\n\n", name));
        } else {
            out.push_str(&format!("## {}\n\n", ctx.source_file));
        }

        if let Some(intent) = &ctx.intent {
            out.push_str(&format!("> {}\n\n", intent));
        }

        // Effect set aliases
        for (name, effects) in &ctx.effect_sets {
            out.push_str(&format!(
                "**effects** `{}` = `[{}]`\n\n",
                name,
                effects.join(", ")
            ));
        }

        // Types
        for td in &ctx.type_defs {
            match td {
                TypeDef::Sum { name, variants } => {
                    out.push_str(&format!("### type {}\n", name));
                    let vars: Vec<String> = variants
                        .iter()
                        .map(|v| {
                            if v.fields.is_empty() {
                                v.name.clone()
                            } else {
                                format!("{}({})", v.name, v.fields.join(", "))
                            }
                        })
                        .collect();
                    out.push_str(&format!("`{}`\n\n", vars.join("` | `")));
                }
                TypeDef::Product { name, fields } => {
                    out.push_str(&format!("### record {}\n", name));
                    let flds: Vec<String> = fields
                        .iter()
                        .map(|(fname, ftype)| format!("{}: {}", fname, ftype))
                        .collect();
                    out.push_str(&format!("`{}`\n\n", flds.join("`, `")));
                }
            }
        }

        // Functions
        for fd in &ctx.fn_defs {
            if fd.name == "main" {
                continue;
            }

            let params: Vec<String> = fd
                .params
                .iter()
                .map(|(pname, ptype)| format!("{}: {}", pname, ptype))
                .collect();
            out.push_str(&format!(
                "### `{}({}) -> {}`\n",
                fd.name,
                params.join(", "),
                fd.return_type
            ));

            if !fd.effects.is_empty() {
                out.push_str(&format!("effects: `[{}]`  \n", fd.effects.join(", ")));
            }

            if let Some(desc) = &fd.desc {
                out.push_str(&format!("> {}\n", desc));
            }

            // Verify cases for this function (max 3)
            for vb in ctx.verify_blocks.iter().filter(|vb| vb.fn_name == fd.name) {
                if vb.cases.is_empty() {
                    continue;
                }
                let max = 3usize;
                let shown: Vec<String> = vb
                    .cases
                    .iter()
                    .take(max)
                    .map(|(lhs, rhs)| format!("`{}` → `{}`", expr_to_str(lhs), expr_to_str(rhs)))
                    .collect();
                let extra = if vb.cases.len() > max {
                    format!(" _(+{} more)_", vb.cases.len() - max)
                } else {
                    String::new()
                };
                out.push_str(&format!("verify: {}{}\n", shown.join(", "), extra));
            }

            out.push('\n');
        }
    }

    // Decisions collected from all files
    if !all_decisions.is_empty() {
        out.push_str("---\n\n## Decisions\n\n");
        for dec in all_decisions {
            out.push_str(&format!("### {} ({})\n", dec.name, dec.date));
            out.push_str(&format!("**Chosen:** {}", dec.chosen));
            if !dec.rejected.is_empty() {
                out.push_str(&format!(" — **Rejected:** {}", dec.rejected.join(", ")));
            }
            out.push('\n');
            if !dec.reason.is_empty() {
                let reason = if dec.reason.len() > 160 {
                    format!("{}…", dec.reason[..160].trim_end())
                } else {
                    dec.reason.clone()
                };
                out.push_str(&format!("> {}\n", reason));
            }
            if !dec.impacts.is_empty() {
                out.push_str(&format!("impacts: `{}`\n", dec.impacts.join("`, `")));
            }
            out.push('\n');
        }
    }

    out
}

pub(super) fn json_str(s: &str) -> String {
    format!(
        "\"{}\"",
        s.replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
    )
}

pub(super) fn format_context_json(contexts: &[FileContext], entry_file: &str) -> String {
    let all_decisions: Vec<&DecisionBlock> =
        contexts.iter().flat_map(|c| c.decisions.iter()).collect();

    let mut out = String::from("{\n");
    out.push_str(&format!("  \"entry\": {},\n", json_str(entry_file)));
    out.push_str("  \"modules\": [\n");

    let non_empty: Vec<&FileContext> = contexts
        .iter()
        .filter(|c| c.module_name.is_some() || !c.fn_defs.is_empty() || !c.type_defs.is_empty())
        .collect();

    for (mi, ctx) in non_empty.iter().enumerate() {
        let comma_m = if mi + 1 < non_empty.len() { "," } else { "" };
        out.push_str("    {\n");
        out.push_str(&format!(
            "      \"source_file\": {},\n",
            json_str(&ctx.source_file)
        ));
        match &ctx.module_name {
            Some(n) => out.push_str(&format!("      \"module\": {},\n", json_str(n))),
            None => out.push_str("      \"module\": null,\n"),
        }
        match &ctx.intent {
            Some(i) => out.push_str(&format!("      \"intent\": {},\n", json_str(i))),
            None => out.push_str("      \"intent\": null,\n"),
        }

        // effect_sets
        out.push_str("      \"effect_sets\": [");
        if ctx.effect_sets.is_empty() {
            out.push_str("],\n");
        } else {
            out.push('\n');
            for (ei, (name, effects)) in ctx.effect_sets.iter().enumerate() {
                let comma_e = if ei + 1 < ctx.effect_sets.len() {
                    ","
                } else {
                    ""
                };
                let effs: Vec<String> = effects.iter().map(|e| json_str(e)).collect();
                out.push_str(&format!(
                    "        {{\"name\": {}, \"effects\": [{}]}}{}\n",
                    json_str(name),
                    effs.join(", "),
                    comma_e
                ));
            }
            out.push_str("      ],\n");
        }

        // types
        out.push_str("      \"types\": [");
        let sum_types: Vec<&TypeDef> = ctx
            .type_defs
            .iter()
            .filter(|td| matches!(td, TypeDef::Sum { .. }))
            .collect();
        if sum_types.is_empty() {
            out.push_str("],\n");
        } else {
            out.push('\n');
            for (ti, td) in sum_types.iter().enumerate() {
                let comma_t = if ti + 1 < sum_types.len() { "," } else { "" };
                if let TypeDef::Sum { name, variants } = td {
                    let vars: Vec<String> = variants
                        .iter()
                        .map(|v| {
                            if v.fields.is_empty() {
                                json_str(&v.name)
                            } else {
                                format!(
                                    "{{\"name\": {}, \"fields\": [{}]}}",
                                    json_str(&v.name),
                                    v.fields
                                        .iter()
                                        .map(|f| json_str(f))
                                        .collect::<Vec<_>>()
                                        .join(", ")
                                )
                            }
                        })
                        .collect();
                    out.push_str(&format!(
                        "        {{\"name\": {}, \"variants\": [{}]}}{}\n",
                        json_str(name),
                        vars.join(", "),
                        comma_t
                    ));
                }
            }
            out.push_str("      ],\n");
        }

        // records
        out.push_str("      \"records\": [");
        let records: Vec<&TypeDef> = ctx
            .type_defs
            .iter()
            .filter(|td| matches!(td, TypeDef::Product { .. }))
            .collect();
        if records.is_empty() {
            out.push_str("],\n");
        } else {
            out.push('\n');
            for (ri, td) in records.iter().enumerate() {
                let comma_r = if ri + 1 < records.len() { "," } else { "" };
                if let TypeDef::Product { name, fields } = td {
                    let flds: Vec<String> = fields
                        .iter()
                        .map(|(fname, ftype)| {
                            format!(
                                "{{\"name\": {}, \"type\": {}}}",
                                json_str(fname),
                                json_str(ftype)
                            )
                        })
                        .collect();
                    out.push_str(&format!(
                        "        {{\"name\": {}, \"fields\": [{}]}}{}\n",
                        json_str(name),
                        flds.join(", "),
                        comma_r
                    ));
                }
            }
            out.push_str("      ],\n");
        }

        // functions
        out.push_str("      \"functions\": [");
        let fns: Vec<&FnDef> = ctx.fn_defs.iter().filter(|fd| fd.name != "main").collect();
        if fns.is_empty() {
            out.push_str("]\n");
        } else {
            out.push('\n');
            for (fi, fd) in fns.iter().enumerate() {
                let comma_f = if fi + 1 < fns.len() { "," } else { "" };
                out.push_str("        {\n");
                out.push_str(&format!("          \"name\": {},\n", json_str(&fd.name)));

                let params: Vec<String> = fd
                    .params
                    .iter()
                    .map(|(pn, pt)| {
                        format!("{{\"name\": {}, \"type\": {}}}", json_str(pn), json_str(pt))
                    })
                    .collect();
                out.push_str(&format!("          \"params\": [{}],\n", params.join(", ")));
                out.push_str(&format!(
                    "          \"return_type\": {},\n",
                    json_str(&fd.return_type)
                ));

                let effs: Vec<String> = fd.effects.iter().map(|e| json_str(e)).collect();
                out.push_str(&format!("          \"effects\": [{}],\n", effs.join(", ")));

                match &fd.desc {
                    Some(d) => out.push_str(&format!("          \"desc\": {},\n", json_str(d))),
                    None => out.push_str("          \"desc\": null,\n"),
                }

                // verify cases (max 3)
                out.push_str("          \"verify\": [");
                let verify_cases: Vec<String> = ctx
                    .verify_blocks
                    .iter()
                    .filter(|vb| vb.fn_name == fd.name)
                    .flat_map(|vb| vb.cases.iter())
                    .take(3)
                    .map(|(lhs, rhs)| {
                        format!(
                            "{{\"input\": {}, \"expected\": {}}}",
                            json_str(&expr_to_str(lhs)),
                            json_str(&expr_to_str(rhs))
                        )
                    })
                    .collect();
                if verify_cases.is_empty() {
                    out.push_str("]\n");
                } else {
                    out.push_str(&format!("{}]\n", verify_cases.join(", ")));
                }

                out.push_str(&format!("        }}{}\n", comma_f));
            }
            out.push_str("      ]\n");
        }

        out.push_str(&format!("    }}{}\n", comma_m));
    }

    out.push_str("  ],\n");

    // decisions
    out.push_str("  \"decisions\": [");
    if all_decisions.is_empty() {
        out.push_str("]\n");
    } else {
        out.push('\n');
        for (di, dec) in all_decisions.iter().enumerate() {
            let comma_d = if di + 1 < all_decisions.len() {
                ","
            } else {
                ""
            };
            out.push_str("    {\n");
            out.push_str(&format!("      \"name\": {},\n", json_str(&dec.name)));
            out.push_str(&format!("      \"date\": {},\n", json_str(&dec.date)));
            out.push_str(&format!("      \"chosen\": {},\n", json_str(&dec.chosen)));
            let rej: Vec<String> = dec.rejected.iter().map(|r| json_str(r)).collect();
            out.push_str(&format!("      \"rejected\": [{}],\n", rej.join(", ")));
            out.push_str(&format!("      \"reason\": {},\n", json_str(&dec.reason)));
            let imp: Vec<String> = dec.impacts.iter().map(|i| json_str(i)).collect();
            out.push_str(&format!("      \"impacts\": [{}],\n", imp.join(", ")));
            match &dec.author {
                Some(a) => out.push_str(&format!("      \"author\": {}\n", json_str(a))),
                None => out.push_str("      \"author\": null\n"),
            }
            out.push_str(&format!("    }}{}\n", comma_d));
        }
        out.push_str("  ]\n");
    }

    out.push('}');
    out
}

pub(super) fn collect_all_decisions(contexts: &[FileContext]) -> Vec<&DecisionBlock> {
    contexts
        .iter()
        .flat_map(|ctx| ctx.decisions.iter())
        .collect()
}

pub(super) fn format_decisions_md(decisions: &[&DecisionBlock], entry_file: &str) -> String {
    let mut out = String::new();
    out.push_str(&format!("# Aver Decisions - {}\n\n", entry_file));
    out.push_str("_Generated by `aver context --decisions-only`_\n\n");
    if decisions.is_empty() {
        out.push_str("No decision blocks found.\n");
        return out;
    }

    for dec in decisions {
        out.push_str(&format!("## {} ({})\n\n", dec.name, dec.date));
        out.push_str(&format!("**Chosen:** {}\n", dec.chosen));
        if !dec.rejected.is_empty() {
            out.push_str(&format!("**Rejected:** {}\n", dec.rejected.join(", ")));
        }
        if !dec.impacts.is_empty() {
            out.push_str(&format!("**Impacts:** {}\n", dec.impacts.join(", ")));
        }
        if !dec.reason.is_empty() {
            out.push_str(&format!("\n> {}\n", dec.reason));
        }
        if let Some(author) = &dec.author {
            out.push_str(&format!("\nAuthor: `{}`\n", author));
        }
        out.push('\n');
    }

    out
}

pub(super) fn format_decisions_json(decisions: &[&DecisionBlock], entry_file: &str) -> String {
    let mut out = String::from("{\n");
    out.push_str(&format!("  \"entry\": {},\n", json_str(entry_file)));
    out.push_str("  \"decisions\": [");
    if decisions.is_empty() {
        out.push_str("]\n");
    } else {
        out.push('\n');
        for (di, dec) in decisions.iter().enumerate() {
            let comma_d = if di + 1 < decisions.len() { "," } else { "" };
            out.push_str("    {\n");
            out.push_str(&format!("      \"name\": {},\n", json_str(&dec.name)));
            out.push_str(&format!("      \"date\": {},\n", json_str(&dec.date)));
            out.push_str(&format!("      \"chosen\": {},\n", json_str(&dec.chosen)));
            let rej: Vec<String> = dec.rejected.iter().map(|r| json_str(r)).collect();
            out.push_str(&format!("      \"rejected\": [{}],\n", rej.join(", ")));
            out.push_str(&format!("      \"reason\": {},\n", json_str(&dec.reason)));
            let imp: Vec<String> = dec.impacts.iter().map(|i| json_str(i)).collect();
            out.push_str(&format!("      \"impacts\": [{}],\n", imp.join(", ")));
            match &dec.author {
                Some(a) => out.push_str(&format!("      \"author\": {}\n", json_str(a))),
                None => out.push_str("      \"author\": null\n"),
            }
            out.push_str(&format!("    }}{}\n", comma_d));
        }
        out.push_str("  ]\n");
    }
    out.push('}');
    out
}
