module Calculator
    intent:
        "Safe calculator demonstrating Result types, match expressions,"
        "and co-located verification. Errors are values, not exceptions."
    exposes [safeDivide, safeRoot]

decision NoExceptions:
    date: "2024-01-15"
    reason:
        "Exceptions make error paths invisible at the call site."
        "Result forces the caller to acknowledge failure explicitly,"
        "which is essential when AI tooling reads code without running it."
    chosen: Result
    rejected: [Exceptions, Nullable]
    impacts: [safeDivide, safeRoot]

fn safeDivide(a: Int, b: Int) -> Result<Int, String>
    ? "Safe integer division. Returns Err when divisor is zero."
    match b:
        0 -> Result.Err("Division by zero")
        _ -> Result.Ok(a / b)

fn safeRoot(n: Int) -> Result<Int, String>
    ? "Returns Err for negative input, Ok otherwise. Uses match on a bool expression."
    match n < 0:
        true  -> Result.Err("Cannot take root of negative number")
        false -> Result.Ok(n)

verify safeRoot:
    safeRoot(4)   => Result.Ok(4)
    safeRoot(0)   => Result.Ok(0)
    safeRoot(-1)  => Result.Err("Cannot take root of negative number")
    safeRoot(-99) => Result.Err("Cannot take root of negative number")

fn main() -> Unit
    ! [Console]
    r1 = safeDivide(10, 2)
    Console.print(r1)
    r2 = safeDivide(7, 0)
    Console.print(r2)
    r3 = safeDivide(9, 3)
    Console.print(r3)

verify safeDivide:
    safeDivide(10, 2) => Result.Ok(5)
    safeDivide(7, 0)  => Result.Err("Division by zero")
    safeDivide(9, 3)  => Result.Ok(3)
    safeDivide(0, 5)  => Result.Ok(0)
