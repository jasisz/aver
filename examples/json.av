module JsonParser
    intent =
        "RFC 8259 JSON parser. Recursive descent, pure, no effects."
        "Supports: integers, floats, strings (with \\uXXXX), bools, null, arrays, objects."
        "Validates: trailing content, leading zeros, control chars, invalid escapes."
    exposes [parse]

type Json
    JsonString(String)
    JsonInt(Int)
    JsonFloat(Float)
    JsonBool(Bool)
    JsonList(List<Json>)
    JsonObject(Map<String, Json>)
    JsonNull

type ParseResult
    Ok(Json, Int)
    Err(String, Int)

// ── Public API ────────────────────────────────────────────────────

fn parse(s: String) -> Result<Json, String>
    ? "Parse a JSON string into a Json value."
    match parseValue(s, skipWs(s, 0))
        ParseResult.Err(msg, p) -> Result.Err(msg + " at position " + String.fromInt(p))
        ParseResult.Ok(val, p) -> checkEof(s, val, skipWs(s, p))

fn checkEof(s: String, val: Json, pos: Int) -> Result<Json, String>
    match String.charAt(s, pos)
        Option.None -> Result.Ok(val)
        Option.Some(c) -> Result.Err("Trailing content: " + c + " at position " + String.fromInt(pos))

// ── Char helpers ──────────────────────────────────────────────────

fn isDigit(c: String) -> Bool
    code = Char.toCode(c)
    match code >= 48
        true -> code <= 57
        false -> false

fn digitVal(c: String) -> Int
    = Char.toCode(c) - 48

fn hexVal(c: String) -> Option<Int>
    ? "Hex digit value: 0-9, a-f, A-F. None for non-hex."
    match isDigit(c)
        true -> Option.Some(digitVal(c))
        false -> hexAlpha(Char.toCode(c))

fn hexAlpha(code: Int) -> Option<Int>
    match code >= 97
        true -> match code <= 102
            true -> Option.Some(code - 87)
            false -> Option.None
        false -> match code >= 65
            true -> match code <= 70
                true -> Option.Some(code - 55)
                false -> Option.None
            false -> Option.None

// ── Whitespace ────────────────────────────────────────────────────

fn skipWs(s: String, pos: Int) -> Int
    match String.charAt(s, pos)
        Option.None -> pos
        Option.Some(c) -> match c
            " " -> skipWs(s, pos + 1)
            "\t" -> skipWs(s, pos + 1)
            "\n" -> skipWs(s, pos + 1)
            "\r" -> skipWs(s, pos + 1)
            _ -> pos

// ── Value dispatch ────────────────────────────────────────────────

fn parseValue(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unexpected end of input", pos)
        Option.Some(c) -> dispatchChar(s, pos, c)

fn dispatchChar(s: String, pos: Int, c: String) -> ParseResult
    match c
        "\"" -> parseString(s, pos + 1, "")
        "{{" -> parseObject(s, skipWs(s, pos + 1))
        "[" -> parseArray(s, skipWs(s, pos + 1))
        "t" -> parseLiteral(s, pos, "true", Json.JsonBool(true))
        "f" -> parseLiteral(s, pos, "false", Json.JsonBool(false))
        "n" -> parseLiteral(s, pos, "null", Json.JsonNull)
        "-" -> parseMinus(s, pos + 1)
        "0" -> parseAfterZero(s, pos + 1, false)
        _ -> startDigits(s, pos, c)

fn startDigits(s: String, pos: Int, c: String) -> ParseResult
    match isDigit(c)
        true -> parseDigits(s, pos + 1, digitVal(c), false)
        false -> ParseResult.Err("Unexpected character: " + c, pos)

// ── Literals ──────────────────────────────────────────────────────

fn parseLiteral(s: String, pos: Int, expected: String, value: Json) -> ParseResult
    ? "Match exact keyword using slice comparison."
    len = String.length(expected)
    match String.slice(s, pos, pos + len) == expected
        true -> ParseResult.Ok(value, pos + len)
        false -> ParseResult.Err("Expected '" + expected + "'", pos)

// ── Strings ───────────────────────────────────────────────────────

fn parseString(s: String, pos: Int, acc: String) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated string", pos)
        Option.Some(c) -> match c
            "\"" -> ParseResult.Ok(Json.JsonString(acc), pos + 1)
            "\\" -> parseEscape(s, pos + 1, acc)
            _ -> validateChar(s, pos, acc, c)

fn validateChar(s: String, pos: Int, acc: String, c: String) -> ParseResult
    match Char.toCode(c) < 32
        true -> ParseResult.Err("Unescaped control character", pos)
        false -> parseString(s, pos + 1, acc + c)

fn parseEscape(s: String, pos: Int, acc: String) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated escape", pos)
        Option.Some(c) -> match c
            "\"" -> parseString(s, pos + 1, acc + "\"")
            "\\" -> parseString(s, pos + 1, acc + "\\")
            "/" -> parseString(s, pos + 1, acc + "/")
            "n" -> parseString(s, pos + 1, acc + "\n")
            "t" -> parseString(s, pos + 1, acc + "\t")
            "r" -> parseString(s, pos + 1, acc + "\r")
            "b" -> parseString(s, pos + 1, acc + "\b")
            "f" -> parseString(s, pos + 1, acc + "\f")
            "u" -> parseUnicode(s, pos + 1, acc)
            _ -> ParseResult.Err("Unknown escape: \\" + c, pos)

fn parseUnicode(s: String, pos: Int, acc: String) -> ParseResult
    ? "Parse \\uXXXX escape sequence."
    match readHex4(s, pos, 0, 0)
        Option.None -> ParseResult.Err("Invalid \\u escape", pos)
        Option.Some(cp) -> applyCodePoint(s, pos + 4, acc, cp)

fn readHex4(s: String, pos: Int, acc: Int, count: Int) -> Option<Int>
    match count == 4
        true -> Option.Some(acc)
        false -> match String.charAt(s, pos)
            Option.None -> Option.None
            Option.Some(c) -> match hexVal(c)
                Option.None -> Option.None
                Option.Some(v) -> readHex4(s, pos + 1, acc * 16 + v, count + 1)

fn applyCodePoint(s: String, pos: Int, acc: String, cp: Int) -> ParseResult
    match Char.fromCode(cp)
        Option.None -> ParseResult.Err("Invalid Unicode code point", pos - 4)
        Option.Some(ch) -> parseString(s, pos, acc + ch)

// ── Numbers ───────────────────────────────────────────────────────

fn parseMinus(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit after '-'", pos)
        Option.Some(c) -> match c
            "0" -> parseAfterZero(s, pos + 1, true)
            _ -> startNegDigit(s, pos, c)

fn startNegDigit(s: String, pos: Int, c: String) -> ParseResult
    match isDigit(c)
        true -> parseDigits(s, pos + 1, digitVal(c), true)
        false -> ParseResult.Err("Expected digit after '-'", pos)

fn parseAfterZero(s: String, pos: Int, neg: Bool) -> ParseResult
    ? "After leading zero: fraction, exponent, or end. No leading zeros."
    match String.charAt(s, pos)
        Option.None -> finishInt(0, neg, pos)
        Option.Some(c) -> match c
            "." -> parseFrac(s, pos + 1, numStr(0, neg) + ".")
            "e" -> parseExp(s, pos + 1, numStr(0, neg) + "e")
            "E" -> parseExp(s, pos + 1, numStr(0, neg) + "e")
            _ -> afterZeroOther(pos, neg, c)

fn afterZeroOther(pos: Int, neg: Bool, c: String) -> ParseResult
    match isDigit(c)
        true -> ParseResult.Err("Leading zeros not allowed", pos)
        false -> finishInt(0, neg, pos)

fn parseDigits(s: String, pos: Int, acc: Int, neg: Bool) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> finishInt(acc, neg, pos)
        Option.Some(c) -> match isDigit(c)
            true -> parseDigits(s, pos + 1, acc * 10 + digitVal(c), neg)
            false -> afterDigits(s, pos, acc, neg, c)

fn afterDigits(s: String, pos: Int, acc: Int, neg: Bool, c: String) -> ParseResult
    match c
        "." -> parseFrac(s, pos + 1, numStr(acc, neg) + ".")
        "e" -> parseExp(s, pos + 1, numStr(acc, neg) + "e")
        "E" -> parseExp(s, pos + 1, numStr(acc, neg) + "e")
        _ -> finishInt(acc, neg, pos)

fn parseFrac(s: String, pos: Int, ns: String) -> ParseResult
    ? "First fraction digit (required after '.')."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit after '.'", pos)
        Option.Some(c) -> match isDigit(c)
            true -> parseFracMore(s, pos + 1, ns + c)
            false -> ParseResult.Err("Expected digit after '.'", pos)

fn parseFracMore(s: String, pos: Int, ns: String) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> finishFloat(ns, pos)
        Option.Some(c) -> match isDigit(c)
            true -> parseFracMore(s, pos + 1, ns + c)
            false -> afterFrac(s, pos, ns, c)

fn afterFrac(s: String, pos: Int, ns: String, c: String) -> ParseResult
    match c
        "e" -> parseExp(s, pos + 1, ns + "e")
        "E" -> parseExp(s, pos + 1, ns + "e")
        _ -> finishFloat(ns, pos)

fn parseExp(s: String, pos: Int, ns: String) -> ParseResult
    ? "Parse exponent: optional sign then digits."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit in exponent", pos)
        Option.Some(c) -> match c
            "+" -> parseExpDigit1(s, pos + 1, ns + "+")
            "-" -> parseExpDigit1(s, pos + 1, ns + "-")
            _ -> startExpDigit(s, pos, ns, c)

fn startExpDigit(s: String, pos: Int, ns: String, c: String) -> ParseResult
    match isDigit(c)
        true -> parseExpMore(s, pos + 1, ns + c)
        false -> ParseResult.Err("Expected digit in exponent", pos)

fn parseExpDigit1(s: String, pos: Int, ns: String) -> ParseResult
    ? "First exponent digit after sign (required)."
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Expected digit in exponent", pos)
        Option.Some(c) -> match isDigit(c)
            true -> parseExpMore(s, pos + 1, ns + c)
            false -> ParseResult.Err("Expected digit in exponent", pos)

fn parseExpMore(s: String, pos: Int, ns: String) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> finishFloat(ns, pos)
        Option.Some(c) -> match isDigit(c)
            true -> parseExpMore(s, pos + 1, ns + c)
            false -> finishFloat(ns, pos)

fn numStr(acc: Int, neg: Bool) -> String
    match neg
        true -> "-" + String.fromInt(acc)
        false -> String.fromInt(acc)

fn finishInt(acc: Int, neg: Bool, pos: Int) -> ParseResult
    match neg
        true -> ParseResult.Ok(Json.JsonInt(acc * -1), pos)
        false -> ParseResult.Ok(Json.JsonInt(acc), pos)

fn finishFloat(ns: String, pos: Int) -> ParseResult
    match Float.fromString(ns)
        Result.Ok(f) -> ParseResult.Ok(Json.JsonFloat(f), pos)
        Result.Err(_) -> ParseResult.Err("Invalid number: " + ns, pos)

// ── Arrays ────────────────────────────────────────────────────────

fn parseArray(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated array", pos)
        Option.Some(c) -> match c
            "]" -> ParseResult.Ok(Json.JsonList([]), pos + 1)
            _ -> parseArrayElems(s, pos, [])

fn parseArrayElems(s: String, pos: Int, acc: List<Json>) -> ParseResult
    match parseValue(s, pos)
        ParseResult.Err(msg, p) -> ParseResult.Err(msg, p)
        ParseResult.Ok(val, p) -> parseArrayNext(s, skipWs(s, p), List.push(acc, val))

fn parseArrayNext(s: String, pos: Int, acc: List<Json>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated array", pos)
        Option.Some(c) -> match c
            "]" -> ParseResult.Ok(Json.JsonList(acc), pos + 1)
            "," -> parseArrayElems(s, skipWs(s, pos + 1), acc)
            _ -> ParseResult.Err("Expected ',' or ']'", pos)

// ── Objects ───────────────────────────────────────────────────────

fn emptyJsonMap() -> Map<String, Json>
    = Map.empty()

fn parseObject(s: String, pos: Int) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            "}}" -> ParseResult.Ok(Json.JsonObject(emptyJsonMap()), pos + 1)
            _ -> parseObjFields(s, pos, emptyJsonMap())

fn parseObjFields(s: String, pos: Int, acc: Map<String, Json>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            "\"" -> parseObjKey(s, pos + 1, acc)
            _ -> ParseResult.Err("Expected string key", pos)

fn parseObjKey(s: String, pos: Int, acc: Map<String, Json>) -> ParseResult
    match parseString(s, pos, "")
        ParseResult.Err(msg, p) -> ParseResult.Err(msg, p)
        ParseResult.Ok(keyJson, p) -> parseObjColon(s, skipWs(s, p), acc, extractStr(keyJson))

fn extractStr(j: Json) -> String
    match j
        Json.JsonString(s) -> s
        _ -> ""

fn parseObjColon(s: String, pos: Int, acc: Map<String, Json>, key: String) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            ":" -> parseObjVal(s, skipWs(s, pos + 1), acc, key)
            _ -> ParseResult.Err("Expected ':'", pos)

fn parseObjVal(s: String, pos: Int, acc: Map<String, Json>, key: String) -> ParseResult
    match parseValue(s, pos)
        ParseResult.Err(msg, p) -> ParseResult.Err(msg, p)
        ParseResult.Ok(val, p) -> parseObjNext(s, skipWs(s, p), Map.set(acc, key, val))

fn parseObjNext(s: String, pos: Int, acc: Map<String, Json>) -> ParseResult
    match String.charAt(s, pos)
        Option.None -> ParseResult.Err("Unterminated object", pos)
        Option.Some(c) -> match c
            "}}" -> ParseResult.Ok(Json.JsonObject(acc), pos + 1)
            "," -> parseObjFields(s, skipWs(s, pos + 1), acc)
            _ -> ParseResult.Err("Expected ',' or '}'", pos)

// ── Extractors ────────────────────────────────────────────────────

fn getField(j: Json, key: String) -> Option<Json>
    match j
        Json.JsonObject(m) -> Map.get(m, key)
        _ -> Option.None

fn jsonStr(j: Json) -> String
    match j
        Json.JsonString(s) -> s
        _ -> ""

fn jsonInt(j: Json) -> Int
    match j
        Json.JsonInt(n) -> n
        _ -> 0

fn jsonFloat(j: Json) -> Float
    match j
        Json.JsonFloat(f) -> f
        _ -> 0.0

fn jsonList(j: Json) -> List<Json>
    match j
        Json.JsonList(items) -> items
        _ -> []

// ── Demo ──────────────────────────────────────────────────────────

fn main() -> Unit
    ! [Console]
    json = "{{ \"name\": \"Aver Labs\", \"score\": 9.75, \"motto\": \"caf\\u00e9 au code\", \"team\": [\"Jan\", \"Anna\"] }}"
    Console.print("Parsing JSON...")
    match parse(json)
        Result.Err(msg) -> Console.print("Error: " + msg)
        Result.Ok(root) -> printResult(root)

fn printResult(root: Json) -> Unit
    ! [Console]
    match getField(root, "name")
        Option.Some(v) -> Console.print("Name: " + jsonStr(v))
        Option.None -> Console.print("Name: ?")
    match getField(root, "score")
        Option.Some(v) -> Console.print("Score: " + String.fromFloat(jsonFloat(v)))
        Option.None -> Console.print("Score: ?")
    match getField(root, "motto")
        Option.Some(v) -> Console.print("Motto: " + jsonStr(v))
        Option.None -> Console.print("Motto: ?")
    match getField(root, "team")
        Option.Some(t) -> Console.print("Team: " + String.join(List.map(jsonList(t), jsonStr), ", "))
        Option.None -> Console.print("Team: ?")

// ── Verify: primitives ───────────────────────────────────────────

verify parse
    parse("null") => Result.Ok(Json.JsonNull)
    parse("true") => Result.Ok(Json.JsonBool(true))
    parse("false") => Result.Ok(Json.JsonBool(false))
    parse("42") => Result.Ok(Json.JsonInt(42))
    parse("-7") => Result.Ok(Json.JsonInt(-7))
    parse("0") => Result.Ok(Json.JsonInt(0))
    parse("-0") => Result.Ok(Json.JsonInt(0))

// ── Verify: floats ───────────────────────────────────────────────

verify parse
    parse("1.5") => Result.Ok(Json.JsonFloat(1.5))
    parse("0.5") => Result.Ok(Json.JsonFloat(0.5))
    parse("-3.14") => Result.Ok(Json.JsonFloat(-3.14))
    parse("1e2") => Result.Ok(Json.JsonFloat(100.0))
    parse("1E2") => Result.Ok(Json.JsonFloat(100.0))
    parse("1e+2") => Result.Ok(Json.JsonFloat(100.0))
    parse("1e-1") => Result.Ok(Json.JsonFloat(0.1))
    parse("1.5e1") => Result.Ok(Json.JsonFloat(15.0))
    parse("0e5") => Result.Ok(Json.JsonFloat(0.0))
    parse("-2.5e3") => Result.Ok(Json.JsonFloat(-2500.0))

// ── Verify: strings and unicode ──────────────────────────────────

verify parse
    parse("\"hello\"") => Result.Ok(Json.JsonString("hello"))
    parse("\"\"") => Result.Ok(Json.JsonString(""))
    parse("\"he\\nllo\"") => Result.Ok(Json.JsonString("he\nllo"))
    parse("\"\\u0041\"") => Result.Ok(Json.JsonString("A"))
    parse("\"caf\\u00e9\"") => Result.Ok(Json.JsonString("café"))

// ── Verify: collections ──────────────────────────────────────────

verify parse
    parse("[]") => Result.Ok(Json.JsonList([]))
    parse("[1,2,3]") => Result.Ok(Json.JsonList([Json.JsonInt(1), Json.JsonInt(2), Json.JsonInt(3)]))
    parse("{{}}") => Result.Ok(Json.JsonObject(emptyJsonMap()))
    parse("{{\"a\":1}}") => Result.Ok(Json.JsonObject(Map.fromList([("a", Json.JsonInt(1))])))
    parse("  {{ \"x\" : [1, 2] , \"y\" : null }}  ") => Result.Ok(Json.JsonObject(Map.fromList([("x", Json.JsonList([Json.JsonInt(1), Json.JsonInt(2)])), ("y", Json.JsonNull)])))

// ── Verify: errors ───────────────────────────────────────────────

verify parse
    parse("true false") => Result.Err("Trailing content: f at position 5")
    parse("42oops") => Result.Err("Trailing content: o at position 2")
    parse("-") => Result.Err("Expected digit after '-' at position 1")
    parse("01") => Result.Err("Leading zeros not allowed at position 1")
    parse("-01") => Result.Err("Leading zeros not allowed at position 2")
    parse("1.") => Result.Err("Expected digit after '.' at position 2")
    parse("1e") => Result.Err("Expected digit in exponent at position 2")
    parse("1e+") => Result.Err("Expected digit in exponent at position 3")
    parse("\"\\uXXXX\"") => Result.Err("Invalid \\u escape at position 3")
    parse("\"\\uD800\"") => Result.Err("Invalid Unicode code point at position 3")
    parse("\"\t\"") => Result.Err("Unescaped control character at position 1")
